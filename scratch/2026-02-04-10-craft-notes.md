# Craft Session Notes — 2026-02-04

**Session start:** 10:28 UTC

## Phase 1: Understanding Bosun

### What Bosun Is
- Local-first AI agent runtime in Rust
- Core principle: "All side effects require an explicit capability"
- Targets M0/M1: sessions, LLM streaming, SQLite event log, capability gate, MCP client

### Documentation Review
The docs are well-written and thoughtful. Observations:
- AGENTS.md → good onboarding, sets expectations
- VISION.md → clear problem statement, concrete principles table
- SPEC.md → detailed schema, CLI commands, crate layout
- STYLE.md → comprehensive, draws from good sources (ripgrep, API guidelines)
- ARCHITECTURE.md → honest about "deferred" work, living document

**Finding:** The SPEC.md says crate layout should include `crates/mcp/` as a separate crate, but actual implementation has MCP integrated into `crates/runtime/src/mcp.rs`. Not necessarily wrong, but spec-code mismatch.

---

## Phase 2: Research - Exemplary Rust Projects

### ripgrep (BurntSushi)
**Key observations:**
- Uses anyhow in the CLI binary for ergonomic error handling
- Clean separation: core crate logic vs. binary entry point
- Heavy use of `#[macro_use]` for custom messaging macros
- Pattern: `ParseResult` enum returns Ok/Err/Special for cleaner CLI flow
- Error handling at boundaries: broken pipe → graceful exit with code 0

**What makes it elegant:**
- Functions are small and focused (search, search_parallel, files, etc.)
- Clear naming: `HiArgs` (high-level args), `haystack_builder`, etc.
- Conditional compilation for allocator choice explained in comments

### axum (tokio-rs)
**Key observations:**
- Extensive doc comments with examples
- Uses `include_str!` for longer documentation
- Clear feature flags with a markdown table in docs
- Trait-based design: FromRequest, FromRequestParts, IntoResponse
- State management documented with 4 different approaches

**What makes it elegant:**
- Documentation reads like a guide
- Examples are runnable and build progressively
- Clear separation of concerns with tower ecosystem

### thiserror (dtolnay)
**Key observations:**
- Very small core with proc-macro doing the heavy lifting
- No-std compatible
- Private modules for implementation details
- Clean re-export: `pub use thiserror_impl::*`

**What makes it elegant:**
- Library does one thing extremely well
- Documentation is exhaustive but not overwhelming
- Invisible in public API (no breaking changes from thiserror usage)

### eza (ls replacement)
**Key observations:**
- Extensive lint configuration at crate level
- Struct with many fields holding app state (Exa struct)
- Separation: Options struct, Theme, etc.
- Uses `log` crate macros throughout

### bat (cat clone)
**Key observations:**
- Very clean lib.rs structure
- Public/private module distinction clear
- Uses `pub(crate)` appropriately
- `#![deny(unsafe_code)]` at the top

**Patterns that stood out:**
1. **Clean module organization in lib.rs** - bat's approach is exemplary
2. **Doc comments as guides** - axum's approach
3. **Strategy for error handling** - thiserror in library, anyhow acceptable in binary
4. **Explicit visibility** - bat's `pub(crate)` usage

---

## Phase 3: Analysis of Bosun

### What's Already Good
1. **Error handling** - Using thiserror consistently, no anyhow in libraries ✓
2. **Type design** - SessionId newtype, EventKind enum, Decision enum
3. **Builder pattern** - AnthropicBackendBuilder follows conventions
4. **STYLE.md** - Comprehensive and aligned with best practices
5. **Capability system** - Clean CapabilityKind enum, CapabilityRequest with scope

### Areas for Improvement

#### 1. **runtime/lib.rs is awkward**
Current:
```rust
pub mod backend;
mod error;
pub mod llm;
pub mod mcp;
mod session;

pub use backend::{...};
pub use error::{Error, Result};
pub use mcp::{...};
pub use session::Session;
```

Problems:
- `llm.rs` exists but is empty (just re-exports)
- `backend` is public but also has re-exports at crate root
- Inconsistent: some modules public, some private with re-exports
- `mcp` module added but documented as separate crate in spec

#### 2. **Unused/placeholder modules**
- `crates/runtime/src/llm.rs` appears to just re-export from backend
- Spec mentions `crates/tools/` but doesn't exist (tools routing)

#### 3. **Public API surface unclear**
Looking at runtime/lib.rs, the API surface is:
- AnthropicAuth, AnthropicBackend, ChatRequest, ChatResponse, LlmBackend, Message
- Error, Result
- CallToolResult, McpClient, McpError, Tool
- Session

This is a flat export. Compare to bat:
```rust
pub mod assets;
pub mod config;
pub mod controller;
pub mod error;
pub mod input;
pub mod line_range;
// etc. - organized by domain
```

#### 4. **Inconsistent module visibility**
- `backend` is `pub mod` but items re-exported at root
- `session` is private with `Session` re-exported
- `mcp` is `pub mod` AND items re-exported at root

This is confusing: can users use `runtime::backend::LlmBackend` or `runtime::LlmBackend`? Both work.

### The Improvement I'll Make

**Target:** Clean up `runtime/lib.rs` module organization and visibility

**Why this matters:**
1. Public API clarity - users should know where to import from
2. Documentation clarity - rustdoc will be cleaner
3. Matches STYLE.md guidance on module organization
4. Aligns with patterns from exemplary projects

**Inspired by:** bat's clean lib.rs structure with explicit visibility

**Changes:**
1. Make module visibility consistent (all private with re-exports at root, OR public modules with no re-exports)
2. Remove empty `llm.rs` module - it adds no value
3. Document the public API in lib.rs doc comment

I'll choose the "all private with re-exports" approach because:
- It's what Bosun already mostly does
- It gives cleaner control over the public API
- It's recommended in Rust API Guidelines

---

## Implementation Plan

1. Remove `llm.rs` (empty/redundant)
2. Make all modules private
3. Keep re-exports at crate root
4. Add a doc comment explaining the public API
5. Run cargo check, clippy, test

---

## Session end time: (to be filled)
## Session duration: (to be filled)
